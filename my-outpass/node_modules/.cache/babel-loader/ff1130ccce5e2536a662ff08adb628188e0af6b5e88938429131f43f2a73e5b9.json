{"ast":null,"code":"'use strict';\n\nconst castFilterPath = require('../query/castFilterPath');\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst getPath = require('../schema/getPath');\nconst updatedPathsByArrayFilter = require('./updatedPathsByArrayFilter');\nmodule.exports = function castArrayFilters(query) {\n  const arrayFilters = query.options.arrayFilters;\n  const update = query.getUpdate();\n  const schema = query.schema;\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n  let strictQuery = schema.options.strict;\n  if (query._mongooseOptions.strict != null) {\n    strictQuery = query._mongooseOptions.strict;\n  }\n  if (query.model && query.model.base.options.strictQuery != null) {\n    strictQuery = query.model.base.options.strictQuery;\n  }\n  if (schema._userProvidedOptions.strictQuery != null) {\n    strictQuery = schema._userProvidedOptions.strictQuery;\n  }\n  if (query._mongooseOptions.strictQuery != null) {\n    strictQuery = query._mongooseOptions.strictQuery;\n  }\n  _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);\n};\nfunction _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {\n  if (!Array.isArray(arrayFilters)) {\n    return;\n  }\n  for (const filter of arrayFilters) {\n    if (filter == null) {\n      throw new Error(`Got null array filter in ${arrayFilters}`);\n    }\n    const keys = Object.keys(filter).filter(key => filter[key] != null);\n    if (keys.length === 0) {\n      continue;\n    }\n    const firstKey = keys[0];\n    if (firstKey === '$and' || firstKey === '$or') {\n      for (const key of keys) {\n        _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);\n      }\n      continue;\n    }\n    const dot = firstKey.indexOf('.');\n    const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);\n    if (updatedPathsByFilter[filterWildcardPath] == null) {\n      continue;\n    }\n    const baseFilterPath = cleanPositionalOperators(updatedPathsByFilter[filterWildcardPath]);\n    const baseSchematype = getPath(schema, baseFilterPath);\n    let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;\n    if (filterBaseSchema != null && filterBaseSchema.discriminators != null && filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]) {\n      filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;\n    }\n    for (const key of keys) {\n      if (updatedPathsByFilter[key] === null) {\n        continue;\n      }\n      if (Object.keys(updatedPathsByFilter).length === 0) {\n        continue;\n      }\n      const dot = key.indexOf('.');\n      let filterPathRelativeToBase = dot === -1 ? null : key.substring(dot);\n      let schematype;\n      if (filterPathRelativeToBase == null || filterBaseSchema == null) {\n        schematype = baseSchematype;\n      } else {\n        // If there are multiple array filters in the path being updated, make sure\n        // to replace them so we can get the schema path.\n        filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);\n        schematype = getPath(filterBaseSchema, filterPathRelativeToBase);\n      }\n      if (schematype == null) {\n        if (!strictQuery) {\n          return;\n        }\n        const filterPath = filterPathRelativeToBase == null ? baseFilterPath + '.0' : baseFilterPath + '.0' + filterPathRelativeToBase;\n        // For now, treat `strictQuery = true` and `strictQuery = 'throw'` as\n        // equivalent for casting array filters. `strictQuery = true` doesn't\n        // quite work in this context because we never want to silently strip out\n        // array filters, even if the path isn't in the schema.\n        throw new Error(`Could not find path \"${filterPath}\" in schema`);\n      }\n      if (typeof filter[key] === 'object') {\n        filter[key] = castFilterPath(query, schematype, filter[key]);\n      } else {\n        filter[key] = schematype.castForQuery(null, filter[key]);\n      }\n    }\n  }\n}","map":{"version":3,"names":["castFilterPath","require","cleanPositionalOperators","getPath","updatedPathsByArrayFilter","module","exports","castArrayFilters","query","arrayFilters","options","update","getUpdate","schema","updatedPathsByFilter","strictQuery","strict","_mongooseOptions","model","base","_userProvidedOptions","_castArrayFilters","Array","isArray","filter","Error","keys","Object","key","length","firstKey","dot","indexOf","filterWildcardPath","substring","baseFilterPath","baseSchematype","filterBaseSchema","discriminators","discriminatorKey","filterPathRelativeToBase","schematype","filterPath","castForQuery"],"sources":["E:/Out/my-outpass/node_modules/mongoose/lib/helpers/update/castArrayFilters.js"],"sourcesContent":["'use strict';\n\nconst castFilterPath = require('../query/castFilterPath');\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst getPath = require('../schema/getPath');\nconst updatedPathsByArrayFilter = require('./updatedPathsByArrayFilter');\n\nmodule.exports = function castArrayFilters(query) {\n  const arrayFilters = query.options.arrayFilters;\n  const update = query.getUpdate();\n  const schema = query.schema;\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  let strictQuery = schema.options.strict;\n  if (query._mongooseOptions.strict != null) {\n    strictQuery = query._mongooseOptions.strict;\n  }\n  if (query.model && query.model.base.options.strictQuery != null) {\n    strictQuery = query.model.base.options.strictQuery;\n  }\n  if (schema._userProvidedOptions.strictQuery != null) {\n    strictQuery = schema._userProvidedOptions.strictQuery;\n  }\n  if (query._mongooseOptions.strictQuery != null) {\n    strictQuery = query._mongooseOptions.strictQuery;\n  }\n\n  _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);\n};\n\nfunction _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {\n  if (!Array.isArray(arrayFilters)) {\n    return;\n  }\n\n  for (const filter of arrayFilters) {\n    if (filter == null) {\n      throw new Error(`Got null array filter in ${arrayFilters}`);\n    }\n    const keys = Object.keys(filter).filter(key => filter[key] != null);\n    if (keys.length === 0) {\n      continue;\n    }\n\n    const firstKey = keys[0];\n    if (firstKey === '$and' || firstKey === '$or') {\n      for (const key of keys) {\n        _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);\n      }\n      continue;\n    }\n    const dot = firstKey.indexOf('.');\n    const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);\n    if (updatedPathsByFilter[filterWildcardPath] == null) {\n      continue;\n    }\n    const baseFilterPath = cleanPositionalOperators(\n      updatedPathsByFilter[filterWildcardPath]\n    );\n\n    const baseSchematype = getPath(schema, baseFilterPath);\n    let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;\n    if (filterBaseSchema != null &&\n        filterBaseSchema.discriminators != null &&\n        filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]) {\n      filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;\n    }\n\n    for (const key of keys) {\n      if (updatedPathsByFilter[key] === null) {\n        continue;\n      }\n      if (Object.keys(updatedPathsByFilter).length === 0) {\n        continue;\n      }\n      const dot = key.indexOf('.');\n\n      let filterPathRelativeToBase = dot === -1 ? null : key.substring(dot);\n      let schematype;\n      if (filterPathRelativeToBase == null || filterBaseSchema == null) {\n        schematype = baseSchematype;\n      } else {\n        // If there are multiple array filters in the path being updated, make sure\n        // to replace them so we can get the schema path.\n        filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);\n        schematype = getPath(filterBaseSchema, filterPathRelativeToBase);\n      }\n\n      if (schematype == null) {\n        if (!strictQuery) {\n          return;\n        }\n        const filterPath = filterPathRelativeToBase == null ?\n          baseFilterPath + '.0' :\n          baseFilterPath + '.0' + filterPathRelativeToBase;\n        // For now, treat `strictQuery = true` and `strictQuery = 'throw'` as\n        // equivalent for casting array filters. `strictQuery = true` doesn't\n        // quite work in this context because we never want to silently strip out\n        // array filters, even if the path isn't in the schema.\n        throw new Error(`Could not find path \"${filterPath}\" in schema`);\n      }\n      if (typeof filter[key] === 'object') {\n        filter[key] = castFilterPath(query, schematype, filter[key]);\n      } else {\n        filter[key] = schematype.castForQuery(null, filter[key]);\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}