{"ast":null,"code":"'use strict';\n\nconst clone = require('../../helpers/clone');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst utils = require('../../utils');\nmodule.exports = assignRawDocsToIdStructure;\nconst kHasArray = Symbol('mongoose#assignRawDocsToIdStructure#hasArray');\n\n/**\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} resultDocs\n * @param {Array} resultOrder\n * @param {Object} options\n * @param {Boolean} recursed\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order, unless we're populating a single\n  // virtual underneath an array (e.g. populating `employees.mostRecentShift` where\n  // `mostRecentShift` is a virtual with `justOne`)\n  const newOrder = [];\n  const sorting = options.isVirtual && options.justOne && rawIds.length > 1 ? false : options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n  if (utils.isMongooseArray(rawIds)) {\n    rawIds = rawIds.__array;\n  }\n  let i = 0;\n  const len = rawIds.length;\n  if (sorting && recursed && options[kHasArray] === undefined) {\n    options[kHasArray] = false;\n    for (const key in resultOrder) {\n      if (Array.isArray(resultOrder[key])) {\n        options[kHasArray] = true;\n        break;\n      }\n    }\n  }\n  for (i = 0; i < len; ++i) {\n    id = rawIds[i];\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n    if (id === null && sorting === false) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n    sid = String(id);\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n          if (options[kHasArray]) {\n            // If result arrays, rely on the MongoDB server response for ordering\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function (doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}","map":{"version":3,"names":["clone","require","leanPopulateMap","modelSymbol","utils","module","exports","assignRawDocsToIdStructure","kHasArray","Symbol","rawIds","resultDocs","resultOrder","options","recursed","newOrder","sorting","isVirtual","justOne","length","sort","nullIfNotFound","$nullIfNotFound","doc","sid","id","isMongooseArray","__array","i","len","undefined","key","Array","isArray","push","String","lean","_model","get","set","constructor","hydrate","_doc","_resultOrder","retainNullValues","forEach"],"sources":["E:/Out/my-outpass/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js"],"sourcesContent":["'use strict';\n\nconst clone = require('../../helpers/clone');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst utils = require('../../utils');\n\nmodule.exports = assignRawDocsToIdStructure;\n\nconst kHasArray = Symbol('mongoose#assignRawDocsToIdStructure#hasArray');\n\n/**\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} resultDocs\n * @param {Array} resultOrder\n * @param {Object} options\n * @param {Boolean} recursed\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order, unless we're populating a single\n  // virtual underneath an array (e.g. populating `employees.mostRecentShift` where\n  // `mostRecentShift` is a virtual with `justOne`)\n  const newOrder = [];\n  const sorting = options.isVirtual && options.justOne && rawIds.length > 1\n    ? false :\n    options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n\n  if (utils.isMongooseArray(rawIds)) {\n    rawIds = rawIds.__array;\n  }\n\n  let i = 0;\n  const len = rawIds.length;\n\n  if (sorting && recursed && options[kHasArray] === undefined) {\n    options[kHasArray] = false;\n    for (const key in resultOrder) {\n      if (Array.isArray(resultOrder[key])) {\n        options[kHasArray] = true;\n        break;\n      }\n    }\n  }\n\n  for (i = 0; i < len; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && sorting === false) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    sid = String(id);\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n          if (options[kHasArray]) {\n            // If result arrays, rely on the MongoDB server response for ordering\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function(doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}