{"ast":null,"code":"'use strict';\n\nconst CastError = require('../../error/cast');\nconst StrictModeError = require('../../error/strict');\nconst castNumber = require('../../cast/number');\nconst omitUndefined = require('../omitUndefined');\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([\n// avoid casting '$add' or '$subtract', because expressions can be either number or date,\n// and we don't have a good way of inferring which arguments should be numbers and which should\n// be dates.\n'$multiply', '$divide', '$log', '$mod', '$trunc', '$avg', '$max', '$min', '$stdDevPop', '$stdDevSamp', '$sum']);\nconst arithmeticOperatorNumber = new Set(['$abs', '$exp', '$ceil', '$floor', '$ln', '$log10', '$sqrt', '$sin', '$cos', '$tan', '$asin', '$acos', '$atan', '$atan2', '$asinh', '$acosh', '$atanh', '$sinh', '$cosh', '$tanh', '$degreesToRadians', '$radiansToDegrees']);\nconst arrayElementOperators = new Set(['$arrayElemAt', '$first', '$last']);\nconst dateOperators = new Set(['$year', '$month', '$week', '$dayOfMonth', '$dayOfYear', '$hour', '$minute', '$second', '$isoDayOfWeek', '$isoWeekYear', '$isoWeek', '$millisecond']);\nconst expressionOperator = new Set(['$not']);\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object');\n  }\n  return _castExpression(val, schema, strictQuery);\n};\nfunction _castExpression(val, schema, strictQuery) {\n  // Preserve the value if it represents a path or if it's null\n  if (isPath(val) || val === null) {\n    return val;\n  }\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    if (Array.isArray(val.$switch.branches)) {\n      val.$switch.branches = val.$switch.branches.map(v => _castExpression(v, schema, strictQuery));\n    }\n    if ('default' in val.$switch) {\n      val.$switch.default = _castExpression(val.$switch.default, schema, strictQuery);\n    }\n  }\n  const keys = Object.keys(val);\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n  if (val.$round) {\n    const $round = val.$round;\n    if (!Array.isArray($round) || $round.length < 1 || $round.length > 2) {\n      throw new CastError('Array', $round, '$round');\n    }\n    val.$round = $round.map(v => castNumberOperator(v, schema, strictQuery));\n  }\n  omitUndefined(val);\n  return val;\n}\n\n// { $op: <number> }\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val);\n  }\n}\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n  if (!isPath(path)) {\n    return val;\n  }\n  const search = val[0];\n  const schematype = schema.path(path.slice(1));\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n    return void 0;\n  }\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n  return [schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search), path];\n}\n\n// { $op: [<number>, <number>] }\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n    try {\n      return castNumber(val);\n    } catch (err) {\n      throw new CastError('Number', val);\n    }\n  }\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n    try {\n      return castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v);\n    }\n  });\n}\n\n// { $op: [expression, expression] }\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n          if (schematype != null) {\n            if (schematype.$isMongooseDocumentArray) {\n              schematype = schematype.$embeddedSchemaType;\n            } else if (schematype.$isMongooseArray) {\n              schematype = schematype.caster;\n            }\n          }\n        }\n      }\n    }\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = {\n          $literal: schematype.cast(val[1].$literal)\n        };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = {\n            $literal: caster(val[1].$literal)\n          };\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n  return val;\n}\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://www.mongodb.com/docs/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n  return true;\n}","map":{"version":3,"names":["CastError","require","StrictModeError","castNumber","omitUndefined","booleanComparison","Set","comparisonOperator","arithmeticOperatorArray","arithmeticOperatorNumber","arrayElementOperators","dateOperators","expressionOperator","module","exports","cast$expr","val","schema","strictQuery","Error","_castExpression","isPath","$cond","Array","isArray","map","expr","if","then","else","$ifNull","v","$switch","branches","default","keys","Object","key","has","castComparison","castArithmetic","castNumberOperator","$in","castIn","$size","$round","length","isLiteral","err","path","search","schematype","slice","$isMongooseArray","$isMongooseDocumentArray","$embeddedSchemaType","cast","caster","lhs","is$literal","$literal","name","replace","find"],"sources":["E:/Out/my-outpass/node_modules/mongoose/lib/helpers/query/cast$expr.js"],"sourcesContent":["'use strict';\n\nconst CastError = require('../../error/cast');\nconst StrictModeError = require('../../error/strict');\nconst castNumber = require('../../cast/number');\nconst omitUndefined = require('../omitUndefined');\n\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([\n  // avoid casting '$add' or '$subtract', because expressions can be either number or date,\n  // and we don't have a good way of inferring which arguments should be numbers and which should\n  // be dates.\n  '$multiply',\n  '$divide',\n  '$log',\n  '$mod',\n  '$trunc',\n  '$avg',\n  '$max',\n  '$min',\n  '$stdDevPop',\n  '$stdDevSamp',\n  '$sum'\n]);\nconst arithmeticOperatorNumber = new Set([\n  '$abs',\n  '$exp',\n  '$ceil',\n  '$floor',\n  '$ln',\n  '$log10',\n  '$sqrt',\n  '$sin',\n  '$cos',\n  '$tan',\n  '$asin',\n  '$acos',\n  '$atan',\n  '$atan2',\n  '$asinh',\n  '$acosh',\n  '$atanh',\n  '$sinh',\n  '$cosh',\n  '$tanh',\n  '$degreesToRadians',\n  '$radiansToDegrees'\n]);\nconst arrayElementOperators = new Set([\n  '$arrayElemAt',\n  '$first',\n  '$last'\n]);\nconst dateOperators = new Set([\n  '$year',\n  '$month',\n  '$week',\n  '$dayOfMonth',\n  '$dayOfYear',\n  '$hour',\n  '$minute',\n  '$second',\n  '$isoDayOfWeek',\n  '$isoWeekYear',\n  '$isoWeek',\n  '$millisecond'\n]);\nconst expressionOperator = new Set(['$not']);\n\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object');\n  }\n\n  return _castExpression(val, schema, strictQuery);\n};\n\nfunction _castExpression(val, schema, strictQuery) {\n  // Preserve the value if it represents a path or if it's null\n  if (isPath(val) || val === null) {\n    return val;\n  }\n\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    if (Array.isArray(val.$switch.branches)) {\n      val.$switch.branches = val.$switch.branches.map(v => _castExpression(v, schema, strictQuery));\n    }\n    if ('default' in val.$switch) {\n      val.$switch.default = _castExpression(val.$switch.default, schema, strictQuery);\n    }\n  }\n\n  const keys = Object.keys(val);\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n  if (val.$round) {\n    const $round = val.$round;\n    if (!Array.isArray($round) || $round.length < 1 || $round.length > 2) {\n      throw new CastError('Array', $round, '$round');\n    }\n    val.$round = $round.map(v => castNumberOperator(v, schema, strictQuery));\n  }\n\n  omitUndefined(val);\n\n  return val;\n}\n\n// { $op: <number> }\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val);\n  }\n}\n\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n  if (!isPath(path)) {\n    return val;\n  }\n  const search = val[0];\n\n  const schematype = schema.path(path.slice(1));\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n\n    return void 0;\n  }\n\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n\n  return [\n    schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),\n    path\n  ];\n}\n\n// { $op: [<number>, <number>] }\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n    try {\n      return castNumber(val);\n    } catch (err) {\n      throw new CastError('Number', val);\n    }\n  }\n\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n    try {\n      return castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v);\n    }\n  });\n}\n\n// { $op: [expression, expression] }\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n          if (schematype != null) {\n            if (schematype.$isMongooseDocumentArray) {\n              schematype = schematype.$embeddedSchemaType;\n            } else if (schematype.$isMongooseArray) {\n              schematype = schematype.caster;\n            }\n          }\n        }\n      }\n    }\n\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = { $literal: schematype.cast(val[1].$literal) };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = { $literal: caster(val[1].$literal) };\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n\n  return val;\n}\n\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\n\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://www.mongodb.com/docs/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n  return true;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}