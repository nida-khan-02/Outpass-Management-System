{"ast":null,"code":"'use strict';\n\nconst middlewareFunctions = require('../../constants').queryMiddlewareFunctions;\nconst promiseOrCallback = require('../promiseOrCallback');\nmodule.exports = function applyStaticHooks(model, hooks, statics) {\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1\n  };\n  hooks = hooks.filter(hook => {\n    // If the custom static overwrites an existing query middleware, don't apply\n    // middleware to it by default. This avoids a potential backwards breaking\n    // change with plugins like `mongoose-delete` that use statics to overwrite\n    // built-in Mongoose functions.\n    if (middlewareFunctions.indexOf(hook.name) !== -1) {\n      return !!hook.model;\n    }\n    return hook.model !== false;\n  });\n  model.$__insertMany = hooks.createWrapper('insertMany', model.$__insertMany, model, kareemOptions);\n  for (const key of Object.keys(statics)) {\n    if (hooks.hasHooks(key)) {\n      const original = model[key];\n      model[key] = function () {\n        const numArgs = arguments.length;\n        const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;\n        const cb = typeof lastArg === 'function' ? lastArg : null;\n        const args = Array.prototype.slice.call(arguments, 0, cb == null ? numArgs : numArgs - 1);\n        // Special case: can't use `Kareem#wrap()` because it doesn't currently\n        // support wrapped functions that return a promise.\n        return promiseOrCallback(cb, callback => {\n          hooks.execPre(key, model, args, function (err) {\n            if (err != null) {\n              return callback(err);\n            }\n            let postCalled = 0;\n            const ret = original.apply(model, args.concat(post));\n            if (ret != null && typeof ret.then === 'function') {\n              ret.then(res => post(null, res), err => post(err));\n            }\n            function post(error, res) {\n              if (postCalled++ > 0) {\n                return;\n              }\n              if (error != null) {\n                return callback(error);\n              }\n              hooks.execPost(key, model, [res], function (error) {\n                if (error != null) {\n                  return callback(error);\n                }\n                callback(null, res);\n              });\n            }\n          });\n        }, model.events);\n      };\n    }\n  }\n};","map":{"version":3,"names":["middlewareFunctions","require","queryMiddlewareFunctions","promiseOrCallback","module","exports","applyStaticHooks","model","hooks","statics","kareemOptions","useErrorHandlers","numCallbackParams","filter","hook","indexOf","name","$__insertMany","createWrapper","key","Object","keys","hasHooks","original","numArgs","arguments","length","lastArg","cb","args","Array","prototype","slice","call","callback","execPre","err","postCalled","ret","apply","concat","post","then","res","error","execPost","events"],"sources":["E:/Out/my-outpass/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js"],"sourcesContent":["'use strict';\n\nconst middlewareFunctions = require('../../constants').queryMiddlewareFunctions;\nconst promiseOrCallback = require('../promiseOrCallback');\n\nmodule.exports = function applyStaticHooks(model, hooks, statics) {\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1\n  };\n\n  hooks = hooks.filter(hook => {\n    // If the custom static overwrites an existing query middleware, don't apply\n    // middleware to it by default. This avoids a potential backwards breaking\n    // change with plugins like `mongoose-delete` that use statics to overwrite\n    // built-in Mongoose functions.\n    if (middlewareFunctions.indexOf(hook.name) !== -1) {\n      return !!hook.model;\n    }\n    return hook.model !== false;\n  });\n\n  model.$__insertMany = hooks.createWrapper('insertMany',\n    model.$__insertMany, model, kareemOptions);\n\n  for (const key of Object.keys(statics)) {\n    if (hooks.hasHooks(key)) {\n      const original = model[key];\n\n      model[key] = function() {\n        const numArgs = arguments.length;\n        const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;\n        const cb = typeof lastArg === 'function' ? lastArg : null;\n        const args = Array.prototype.slice.\n          call(arguments, 0, cb == null ? numArgs : numArgs - 1);\n        // Special case: can't use `Kareem#wrap()` because it doesn't currently\n        // support wrapped functions that return a promise.\n        return promiseOrCallback(cb, callback => {\n          hooks.execPre(key, model, args, function(err) {\n            if (err != null) {\n              return callback(err);\n            }\n\n            let postCalled = 0;\n            const ret = original.apply(model, args.concat(post));\n            if (ret != null && typeof ret.then === 'function') {\n              ret.then(res => post(null, res), err => post(err));\n            }\n\n            function post(error, res) {\n              if (postCalled++ > 0) {\n                return;\n              }\n\n              if (error != null) {\n                return callback(error);\n              }\n\n              hooks.execPost(key, model, [res], function(error) {\n                if (error != null) {\n                  return callback(error);\n                }\n                callback(null, res);\n              });\n            }\n          });\n        }, model.events);\n      };\n    }\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}