{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst CastError = require('../error/cast');\nconst DocumentArrayElement = require('./documentArrayElement');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaArray = require('./array');\nconst SchemaDocumentArrayOptions = require('../options/schemaDocumentArrayOptions');\nconst SchemaType = require('../schemaType');\nconst cast = require('../cast');\nconst discriminator = require('../helpers/model/discriminator');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\nconst isOperator = require('../helpers/query/isOperator');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst InvalidSchemaOptionError = require('../error/invalidSchemaOption');\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaArray\n * @api public\n */\n\nfunction SchemaDocumentArray(key, schema, options, schemaOptions) {\n  if (schema.options && schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(key, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaDocumentArray.defaultOptions && SchemaDocumentArray.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    schemaOptions = schemaOptions || {};\n    schemaOptions._id = schemaTypeIdOption;\n  }\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n  SchemaArray.call(this, key, EmbeddedDocument, options);\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n  EmbeddedDocument.base = schema.base;\n  const fn = this.defaultValue;\n  if (!('defaultValue' in this) || fn != null) {\n    this.default(function () {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n  const $parentSchemaType = this;\n  this.$embeddedSchemaType = new DocumentArrayElement(key + '.$', {\n    required: this && this.schemaOptions && this.schemaOptions.required || false,\n    $parentSchemaType\n  });\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArray.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nSchemaDocumentArray.options = {\n  castNonArrays: true\n};\n\n/*!\n * Inherits from SchemaArray.\n */\nSchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);\nSchemaDocumentArray.prototype.constructor = SchemaDocumentArray;\nSchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\nSchemaDocumentArray.prototype.$conditionalHandlers = {\n  ...SchemaArray.prototype.$conditionalHandlers\n};\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/arraySubdocument'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(this.__parentArray.getArrayParent().$session());\n  }\n  schema._preCompile();\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n  EmbeddedDocument.base = schema.base;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n  EmbeddedDocument.options = options;\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nSchemaDocumentArray.prototype.discriminator = function (name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue, null, null, options?.overwriteExisting);\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidate = function (array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n    let count = array && array.length;\n    let error;\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!utils.isMongooseDocumentArray(array)) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n      doc.$__validate(null, options, callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidateSync = function (array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n  const count = array && array.length;\n  let resultError = null;\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n    const subdocValidateError = doc.validateSync(options);\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.getDefault = function (scope, init, options) {\n  let ret = typeof this.defaultValue === 'function' ? this.defaultValue.call(scope) : this.defaultValue;\n  if (ret == null) {\n    return ret;\n  }\n  if (options && options.skipCast) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined, undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n    ret[i] = _subdoc;\n  }\n  return ret;\n};\nconst _toObjectOptions = Object.freeze({\n  transform: false,\n  virtuals: false\n});\nconst initDocumentOptions = Object.freeze({\n  skipId: false,\n  willInit: true\n});\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nSchemaDocumentArray.prototype.cast = function (value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n  let selected;\n  let subdoc;\n  options = options || {};\n  const path = options.path || this.path;\n  if (!Array.isArray(value)) {\n    if (!init && !SchemaDocumentArray.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, path, doc);\n  }\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = path + '.' + options.arrayPathIndex;\n  }\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n    const Constructor = getConstructor(this.casterConstructor, rawArray[i]);\n    const spreadDoc = handleSpreadDoc(rawArray[i], true);\n    if (rawArray[i] !== spreadDoc) {\n      rawArray[i] = spreadDoc;\n    }\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i], value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n  return value;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.clone = function () {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({}, this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.applyGetters = function (value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array the array to scope `fields` paths\n * @param {Object|undefined} fields the root fields selected in the query\n * @param {Boolean|undefined} init if we are being created part of a query result\n * @api private\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.defaultOptions = {};\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDocumentArray.set = SchemaType.set;\nSchemaDocumentArray.setters = [];\n\n/**\n * Attaches a getter for all DocumentArrayPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDocumentArray.get = SchemaType.get;\n\n/*!\n * Handle casting $elemMatch operators\n */\n\nSchemaDocumentArray.prototype.$conditionalHandlers.$elemMatch = cast$elemMatch;\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.options && this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this && this.casterConstructor && this.casterConstructor.schema && this.casterConstructor.schema.discriminators || {};\n  if (discriminatorKey != null && val[discriminatorKey] != null && discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);\n  }\n  const schema = this.casterConstructor.schema ?? context.schema;\n  return cast(schema, val, null, this && this.$$context);\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArray;","map":{"version":3,"names":["CastError","require","DocumentArrayElement","EventEmitter","SchemaArray","SchemaDocumentArrayOptions","SchemaType","cast","discriminator","handleIdOption","handleSpreadDoc","isOperator","utils","getConstructor","InvalidSchemaOptionError","arrayAtomicsSymbol","arrayPathSymbol","documentArrayParent","MongooseDocumentArray","Subdocument","SchemaDocumentArray","key","schema","options","schemaOptions","timeseries","schemaTypeIdOption","defaultOptions","_id","EmbeddedDocument","_createConstructor","prototype","$basePath","call","$isMongooseDocumentArray","Constructor","base","fn","defaultValue","default","arr","Array","isArray","$parentSchemaType","$embeddedSchemaType","required","caster","schemaName","castNonArrays","Object","create","constructor","OptionsConstructor","$conditionalHandlers","baseClass","apply","arguments","__parentArray","getArrayParent","$session","_preCompile","proto","$__setSchema","$isArraySubdocument","events","i","methods","statics","name","getFunctionName","tiedValue","isPOJO","value","clone","instanceOfSchema","casterConstructor","overwriteExisting","baseCasterConstructor","defineProperty","error","discriminators","doValidate","array","scope","_this","cb","err","count","length","updateValidator","isMongooseDocumentArray","path","callback","len","doc","undefined","validateModifiedOnly","$isModified","$__validate","doValidateSync","schemaTypeError","resultError","subdocValidateError","validateSync","getDefault","init","ret","skipCast","_subdoc","$init","isNew","assign","$__","activePaths","_toObjectOptions","freeze","transform","virtuals","initDocumentOptions","skipId","willInit","prev","selected","subdoc","markModified","skipDocumentArrayCast","arrayPathIndex","rawArray","__array","spreadDoc","__index","$setIndex","scopePaths","id","deepEqual","toObject","set","schematype","validators","slice","requiredValidator","applyGetters","fields","keys","hasKeys","sub","startsWith","substring","setters","get","$elemMatch","cast$elemMatch","val","context","numKeys","castForQuery","discriminatorKey","$$context","module","exports"],"sources":["E:/Out/my-outpass/node_modules/mongoose/lib/schema/documentArray.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst DocumentArrayElement = require('./documentArrayElement');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaArray = require('./array');\nconst SchemaDocumentArrayOptions =\n  require('../options/schemaDocumentArrayOptions');\nconst SchemaType = require('../schemaType');\nconst cast = require('../cast');\nconst discriminator = require('../helpers/model/discriminator');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\nconst isOperator = require('../helpers/query/isOperator');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst InvalidSchemaOptionError = require('../error/invalidSchemaOption');\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaArray\n * @api public\n */\n\nfunction SchemaDocumentArray(key, schema, options, schemaOptions) {\n  if (schema.options && schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(key, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaDocumentArray.defaultOptions &&\n    SchemaDocumentArray.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    schemaOptions = schemaOptions || {};\n    schemaOptions._id = schemaTypeIdOption;\n  }\n\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  SchemaArray.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn != null) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const $parentSchemaType = this;\n  this.$embeddedSchemaType = new DocumentArrayElement(key + '.$', {\n    required: this &&\n      this.schemaOptions &&\n      this.schemaOptions.required || false,\n    $parentSchemaType\n  });\n\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArray.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nSchemaDocumentArray.options = { castNonArrays: true };\n\n/*!\n * Inherits from SchemaArray.\n */\nSchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);\nSchemaDocumentArray.prototype.constructor = SchemaDocumentArray;\nSchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\nSchemaDocumentArray.prototype.$conditionalHandlers = { ...SchemaArray.prototype.$conditionalHandlers };\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/arraySubdocument'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(this.__parentArray.getArrayParent().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n  EmbeddedDocument.base = schema.base;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nSchemaDocumentArray.prototype.discriminator = function(name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue, null, null, options?.overwriteExisting);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!utils.isMongooseDocumentArray(array)) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(null, options, callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidateSync = function(array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync(options);\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.getDefault = function(scope, init, options) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  if (options && options.skipCast) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\nconst _toObjectOptions = Object.freeze({ transform: false, virtuals: false });\nconst initDocumentOptions = Object.freeze({ skipId: false, willInit: true });\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nSchemaDocumentArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n\n  options = options || {};\n\n  const path = options.path || this.path;\n\n  if (!Array.isArray(value)) {\n    if (!init && !SchemaDocumentArray.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, path, doc);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, rawArray[i]);\n\n    const spreadDoc = handleSpreadDoc(rawArray[i], true);\n    if (rawArray[i] !== spreadDoc) {\n      rawArray[i] = spreadDoc;\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i]);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i],\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.applyGetters = function(value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array the array to scope `fields` paths\n * @param {Object|undefined} fields the root fields selected in the query\n * @param {Boolean|undefined} init if we are being created part of a query result\n * @api private\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.defaultOptions = {};\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDocumentArray.set = SchemaType.set;\n\nSchemaDocumentArray.setters = [];\n\n/**\n * Attaches a getter for all DocumentArrayPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDocumentArray.get = SchemaType.get;\n\n/*!\n * Handle casting $elemMatch operators\n */\n\nSchemaDocumentArray.prototype.$conditionalHandlers.$elemMatch = cast$elemMatch;\n\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this &&\n    this.casterConstructor &&\n    this.casterConstructor.schema &&\n    this.casterConstructor.schema.options &&\n    this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this &&\n  this.casterConstructor &&\n  this.casterConstructor.schema &&\n  this.casterConstructor.schema.discriminators || {};\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);\n  }\n\n  const schema = this.casterConstructor.schema ?? context.schema;\n  return cast(schema, val, null, this && this.$$context);\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArray;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}