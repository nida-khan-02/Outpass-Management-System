{"ast":null,"code":"'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst clone = require('../clone');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\nconst utils = require('../../utils');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst StrictPopulate = require('../../error/strictPopulate');\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null && schema.$isMongooseDocumentArray && schema.options.ref == null && schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path + ' because it is a subproperty of a document array');\n    }\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n      if (!modelNames) {\n        continue;\n      }\n    }\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ? schema.every(schema => !schema.$isMongooseArray) : !schema.$isMongooseArray;\n      }\n    }\n    if (!modelNames) {\n      continue;\n    }\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n    let match = get(options, 'match', null);\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret);\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n    const originalSchema = schema;\n    if (schema && schema.instance === 'Array') {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n    if (schema != null && schema[schemaMixedSymbol] && !ref && !refPath && !modelNameFromQuery) {\n      return {\n        modelNames: null\n      };\n    }\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null && typeof ref === 'function' && options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ? utils.array.flatten(vals) : vals ? [vals] : [];\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return {\n          modelNames: modelNames,\n          justOne: justOne,\n          isRefPath: isRefPath,\n          refPath: refPath\n        };\n      }\n    }\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n    return {\n      modelNames: modelNames,\n      justOne: justOne,\n      isRefPath: isRefPath,\n      refPath: refPath\n    };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ? _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n    modelNames = virtual._getModelNamesForPopulate(doc);\n    if (virtual.options.refPath) {\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      justOne = !!virtual.options.justOne;\n    }\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) || get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n  if (modelNames == null) {\n    return;\n  }\n  let k = modelNames.length;\n  while (k--) {\n    let modelName = modelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n      modelName = Model.modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n    let ids = ret;\n    const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n    if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {\n      ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);\n    }\n    const perDocumentLimit = options.perDocumentLimit == null ? get(options, 'options.perDocumentLimit', null) : options.perDocumentLimit;\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n  return conn.model(modelName);\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ? model.schema.path(localField) : localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ? localFieldPath.getters : [];\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n  const _populateOptions = get(options, 'options', {});\n  const getters = 'getters' in _populateOptions ? _populateOptions.getters : get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = doc.$__ != null ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) => localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._doc._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._doc._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' && (\n  // The intent here is we should only flatten the object if we expect\n  // to get a Map in the end. Avoid doing this for mixed types.\n  schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null && schematype.$isMongooseArray && schematype.caster.discriminators != null && Object.keys(schematype.caster.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.caster.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n  return modelNames;\n}","map":{"version":3,"names":["MongooseError","require","SkipPopulateValue","clone","get","getDiscriminatorByValue","getConstructorName","getSchemaTypes","getVirtual","lookupLocalFields","mpath","modelNamesFromRefPath","utils","modelSymbol","populateModelSymbol","schemaMixedSymbol","StrictPopulate","module","exports","getModelsMapForPopulate","model","docs","options","doc","len","length","map","modelNameFromQuery","modelName","schema","refPath","modelNames","available","modelSchema","_localModel","nested","path","_virtualRes","virtual","_virtualPopulate","allSchemaTypes","Array","isArray","filter","v","isStrictPopulateDisabled","strictPopulate","_fullPath","i","justOne","docSchema","$__","$__schema","$isMongooseDocumentArray","ref","isUnderneathDocArray","$parentSchemaDocArray","isRefPath","normalizedRefPath","schemaOptions","modelNamesInOrder","instance","data","localField","foreignField","res","_getModelNames","unpopulatedValue","id","addModelNamesToMap","schemasArray","_schema","_modelNames","error","indexOf","push","from","Set","endsWith","every","$isMongooseArray","isVirtual","ret","_getLocalFieldValues","String","getValue","_docs","slice","match","hasMatchFunction","call","embeddedDiscriminatorModelNames","_findRefPathForDiscriminators","err","originalSchema","caster","$isSchemaMap","$__schemaType","subdocPath","vals","subdocsBeingPopulated","array","flatten","subdoc","_queryProjection","forEach","name","add","schemaForCurrentDoc","discriminatorValue","modelForCurrentDoc","discriminatorKey","discriminatorModel","discriminators","_getModelFromConn","db","_getSchema","_arrayPath","handleRefFunction","virtualPrefix","nestedSchemaPath","field","count","skip","hasOwnProperty","limit","perDocumentLimit","_getModelNamesForPopulate","baseMatch","Object","assign","convertTo_id","connection","cloneArrays","k","Model","ids","flat","modelNamesForRefPath","val","currentOptions","merge","allIds","unpopulatedValues","conn","models","_parent","localFieldPathType","_getPathType","localFieldPath","localFieldGetters","getters","_populateOptions","hydratedDoc","hydrate","localFieldValue","localFieldHydratedValue","split","localFieldArrVal","localFieldArrIndex","applyGetters","_doc","_id","rawVal","__array","isMongooseArray","$schema","_castForPopulate","$parent","concat","key","keys","Map","values","pieces","cur","piece","schematype","subdocs","remnant","substring","discriminatorName","discriminator","discriminatorSchema","_path","docValue","join"],"sources":["E:/Out/my-outpass/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst clone = require('../clone');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\nconst utils = require('../../utils');\n\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst StrictPopulate = require('../../error/strictPopulate');\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null &&\n        schema.$isMongooseDocumentArray &&\n        schema.options.ref == null &&\n        schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ?\n          schema.every(schema => !schema.$isMongooseArray) :\n          !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    let match = get(options, 'match', null);\n\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc,\n        modelSchema, data, options, normalizedRefPath, ret);\n\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n\n    const originalSchema = schema;\n    if (schema && schema.instance === 'Array') {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n    if (schema != null &&\n        schema[schemaMixedSymbol] &&\n        !ref &&\n        !refPath &&\n        !modelNameFromQuery) {\n      return { modelNames: null };\n    }\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ?\n          utils.array.flatten(vals) :\n          (vals ? [vals] : []);\n\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n            forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null &&\n            typeof ref === 'function' &&\n            options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n              forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n      }\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ?\n      _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n\n    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    modelNames = virtual._getModelNamesForPopulate(doc);\n    if (virtual.options.refPath) {\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      justOne = !!virtual.options.justOne;\n    }\n\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) ||\n      get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n\n  if (modelNames == null) {\n    return;\n  }\n\n  let k = modelNames.length;\n  while (k--) {\n    let modelName = modelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n      modelName = Model.modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n\n    let ids = ret;\n    const flat = Array.isArray(ret) ? utils.array.flatten(ret) : [];\n\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n    if (data.isRefPath && Array.isArray(ret) && flat.length === modelNamesForRefPath.length) {\n      ids = flat.filter((val, i) => modelNamesForRefPath[i] === modelName);\n    }\n\n    const perDocumentLimit = options.perDocumentLimit == null ?\n      get(options, 'options.perDocumentLimit', null) :\n      options.perDocumentLimit;\n\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\n\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n\n  return conn.model(modelName);\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ?\n    model.schema.path(localField) :\n    localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ?\n    localFieldPath.getters : [];\n\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n\n  const _populateOptions = get(options, 'options', {});\n\n  const getters = 'getters' in _populateOptions ?\n    _populateOptions.getters :\n    get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\n        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._doc._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._doc._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n      // The intent here is we should only flatten the object if we expect\n      // to get a Map in the end. Avoid doing this for mixed types.\n      (schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null &&\n        schematype.$isMongooseArray &&\n        schematype.caster.discriminators != null &&\n        Object.keys(schematype.caster.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.caster.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n\n  return modelNames;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}