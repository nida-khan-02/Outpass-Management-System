{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst CastError = require('./error/cast');\nconst StrictModeError = require('./error/strict');\nconst Types = require('./schema/index');\nconst cast$expr = require('./helpers/query/cast$expr');\nconst castString = require('./cast/string');\nconst castTextSearch = require('./schema/operators/text');\nconst get = require('./helpers/get');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst isOperator = require('./helpers/query/isOperator');\nconst util = require('util');\nconst isObject = require('./helpers/isObject');\nconst isMongooseObject = require('./helpers/isMongooseObject');\nconst utils = require('./utils');\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} [options] the query options\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\n * @param {Boolean} [options.upsert]\n * @param {Query} [context] passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n  if (obj == null) {\n    return obj;\n  }\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n  options = options || {};\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = 0; k < val.length; ++k) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        const discriminatorValue = val[k][schema.options.discriminatorKey];\n        if (discriminatorValue == null) {\n          val[k] = cast(schema, val[k], options, context);\n        } else {\n          const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);\n          val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);\n        }\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n      continue;\n    } else if (path === '$expr') {\n      val = cast$expr(val, schema);\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else if (path === '$comment' && !schema.paths.hasOwnProperty('$comment')) {\n      val = castString(val, path);\n      obj[path] = val;\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = _schematype && _schematype.schema && _schematype.schema.options && _schematype.schema.options.discriminatorKey;\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null && (_schematype.schema && _schematype.schema.discriminators) != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            const discriminators = _schematype.schema.discriminators;\n            if (typeof discriminatorVal === 'string' && discriminators[discriminatorVal] != null) {\n              schematype = discriminators[discriminatorVal].path(pathLastHalf);\n            } else if (discriminatorVal != null && Object.keys(discriminatorVal).length === 1 && Array.isArray(discriminatorVal.$in) && discriminatorVal.$in.length === 1 && typeof discriminatorVal.$in[0] === 'string' && discriminators[discriminatorVal.$in[0]] != null) {\n              schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);\n            }\n          }\n        }\n      }\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n            if (ret === void 0) {\n              delete obj[path];\n            } else {\n              obj[path] = ret;\n            }\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(null, val.$maxDistance, context);\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(null, val.$minDistance, context);\n            }\n            if (geo === '$within') {\n              const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n              value = withinType;\n            } else if (geo === '$near' && typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') && value.$geometry && typeof value.$geometry.type === 'string' && Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(null, value.$maxDistance, context);\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(null, value.$minDistance, context);\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({\n                    virtuals: false\n                  });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' + geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center || value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({\n                    virtuals: false\n                  });\n                }\n              }\n            }\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n        if (schema.nested[path]) {\n          continue;\n        }\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\n        if (options.upsert && strict) {\n          if (strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema, strict mode is `true`, and upsert is `true`.');\n        }\n        if (strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema and strictQuery is \\'throw\\'.');\n        } else if (strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (utils.isPOJO(val)) {\n        any$conditionals = Object.keys(val).some(isOperator);\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(null, val, context);\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$elemMatch') {\n              if (nested && schematype != null && schematype.schema != null) {\n                cast(schematype.schema, nested, options, context);\n              } else if (nested && schematype != null && schematype.$isMongooseArray) {\n                if (utils.isPOJO(nested) && nested.$not != null) {\n                  cast(schema, nested, options, context);\n                } else {\n                  val[$cond] = schematype.castForQuery($cond, nested, context);\n                }\n              }\n            } else if ($cond === '$not') {\n              if (nested && schematype) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQuery(key, nested[key], context);\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery($cond, nested, context);\n                }\n                continue;\n              }\n            } else {\n              val[$cond] = schematype.castForQuery($cond, nested, context);\n            }\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        const valuesArray = val;\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQuery(null, _val, context));\n        }\n        obj[path] = {\n          $in: casted\n        };\n      } else {\n        obj[path] = schematype.castForQuery(null, val, context);\n      }\n    }\n  }\n  return obj;\n};\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function (item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQuery(null, item, context);\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({\n          val: item,\n          context: context\n        });\n      }\n    }\n  }\n}\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\n  if ('strictQuery' in queryOptions) {\n    return queryOptions.strictQuery;\n  }\n  if ('strictQuery' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strictQuery;\n  }\n  const mongooseOptions = context && context.mongooseCollection && context.mongooseCollection.conn && context.mongooseCollection.conn.base && context.mongooseCollection.conn.base.options;\n  if (mongooseOptions) {\n    if ('strictQuery' in mongooseOptions) {\n      return mongooseOptions.strictQuery;\n    }\n  }\n  return schemaOptions.strictQuery;\n}","map":{"version":3,"names":["CastError","require","StrictModeError","Types","cast$expr","castString","castTextSearch","get","getSchemaDiscriminatorByValue","isOperator","util","isObject","isMongooseObject","utils","ALLOWED_GEOWITHIN_GEOJSON_TYPES","module","exports","cast","schema","obj","options","context","Array","isArray","Error","inspect","discriminators","discriminatorKey","paths","Object","keys","i","length","_keys","any$conditionals","schematype","nested","path","type","val","k","discriminatorValue","discriminatorSchema","toString","hasOwnProperty","split","j","pathFirstHalf","slice","join","pathLastHalf","_schematype","discriminatorVal","$in","remainingConds","caster","ret","geo","$near","$nearSphere","$within","$geoIntersects","$geoWithin","numbertype","Number","value","$maxDistance","castForQuery","$minDistance","withinType","$center","$centerSphere","$box","$polygon","JSON","stringify","coordinates","$geometry","toObject","transform","virtuals","geoWithinType","indexOf","_cast","strict","strictQuery","getStrictQuery","_userProvidedOptions","upsert","isPOJO","some","ks","$cond","$isMongooseArray","$not","key","instance","casted","valuesArray","_val","push","forEach","item","nearKeys","nearLen","nkey","queryOptions","schemaUserProvidedOptions","schemaOptions","mongooseOptions","mongooseCollection","conn","base"],"sources":["E:/Out/my-outpass/node_modules/mongoose/lib/cast.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('./error/cast');\nconst StrictModeError = require('./error/strict');\nconst Types = require('./schema/index');\nconst cast$expr = require('./helpers/query/cast$expr');\nconst castString = require('./cast/string');\nconst castTextSearch = require('./schema/operators/text');\nconst get = require('./helpers/get');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst isOperator = require('./helpers/query/isOperator');\nconst util = require('util');\nconst isObject = require('./helpers/isObject');\nconst isMongooseObject = require('./helpers/isMongooseObject');\nconst utils = require('./utils');\n\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} [options] the query options\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\n * @param {Boolean} [options.upsert]\n * @param {Query} [context] passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n\n  options = options || {};\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = 0; k < val.length; ++k) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        const discriminatorValue = val[k][schema.options.discriminatorKey];\n        if (discriminatorValue == null) {\n          val[k] = cast(schema, val[k], options, context);\n        } else {\n          const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);\n          val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);\n        }\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$expr') {\n      val = cast$expr(val, schema);\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else if (path === '$comment' && !schema.paths.hasOwnProperty('$comment')) {\n      val = castString(val, path);\n      obj[path] = val;\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = _schematype &&\n            _schematype.schema &&\n            _schematype.schema.options &&\n            _schematype.schema.options.discriminatorKey;\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null &&\n            (_schematype.schema && _schematype.schema.discriminators) != null &&\n            discriminatorKey != null &&\n            pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            const discriminators = _schematype.schema.discriminators;\n            if (typeof discriminatorVal === 'string' && discriminators[discriminatorVal] != null) {\n\n              schematype = discriminators[discriminatorVal].path(pathLastHalf);\n            } else if (discriminatorVal != null &&\n              Object.keys(discriminatorVal).length === 1 &&\n              Array.isArray(discriminatorVal.$in) &&\n              discriminatorVal.$in.length === 1 &&\n              typeof discriminatorVal.$in[0] === 'string' &&\n              discriminators[discriminatorVal.$in[0]] != null) {\n              schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);\n            }\n          }\n        }\n      }\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n\n            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n            if (ret === void 0) {\n              delete obj[path];\n            } else {\n              obj[path] = ret;\n            }\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(\n                null,\n                val.$maxDistance,\n                context\n              );\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(\n                null,\n                val.$minDistance,\n                context\n              );\n            }\n\n            if (geo === '$within') {\n              const withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(\n                  null,\n                  value.$maxDistance,\n                  context\n                );\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(\n                  null,\n                  value.$minDistance,\n                  context\n                );\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n\n        if (schema.nested[path]) {\n          continue;\n        }\n\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\n        if (options.upsert && strict) {\n          if (strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        } if (strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema and strictQuery is \\'throw\\'.');\n        } else if (strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (utils.isPOJO(val)) {\n        any$conditionals = Object.keys(val).some(isOperator);\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(\n            null,\n            val,\n            context\n          );\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$elemMatch') {\n              if (nested && schematype != null && schematype.schema != null) {\n                cast(schematype.schema, nested, options, context);\n              } else if (nested && schematype != null && schematype.$isMongooseArray) {\n                if (utils.isPOJO(nested) && nested.$not != null) {\n                  cast(schema, nested, options, context);\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n              }\n            } else if ($cond === '$not') {\n              if (nested && schematype) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQuery(\n                      key,\n                      nested[key],\n                      context\n                    );\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n                continue;\n              }\n            } else {\n              val[$cond] = schematype.castForQuery(\n                $cond,\n                nested,\n                context\n              );\n            }\n\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        const valuesArray = val;\n\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQuery(\n            null,\n            _val,\n            context\n          ));\n        }\n\n        obj[path] = { $in: casted };\n      } else {\n        obj[path] = schematype.castForQuery(\n          null,\n          val,\n          context\n        );\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQuery(null, item, context);\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({ val: item, context: context });\n      }\n    }\n  }\n}\n\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\n  if ('strictQuery' in queryOptions) {\n    return queryOptions.strictQuery;\n  }\n  if ('strictQuery' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strictQuery;\n  }\n  const mongooseOptions = context &&\n    context.mongooseCollection &&\n    context.mongooseCollection.conn &&\n    context.mongooseCollection.conn.base &&\n    context.mongooseCollection.conn.base.options;\n  if (mongooseOptions) {\n    if ('strictQuery' in mongooseOptions) {\n      return mongooseOptions.strictQuery;\n    }\n  }\n  return schemaOptions.strictQuery;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}