{"ast":null,"code":"'use strict';\n\nconst CastError = require('../../error/cast');\nconst MongooseError = require('../../error/mongooseError');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst cast = require('../../cast');\nconst getConstructorName = require('../getConstructorName');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst handleImmutable = require('./handleImmutable');\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst setDottedPath = require('../path/setDottedPath');\nconst utils = require('../../utils');\nconst {\n  internalToObjectOptions\n} = require('../../options');\nconst mongodbUpdateOperators = new Set(['$currentDate', '$inc', '$min', '$max', '$mul', '$rename', '$set', '$setOnInsert', '$unset', '$addToSet', '$pop', '$pull', '$push', '$pullAll', '$bit']);\n\n/**\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n * @api private\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    if (!mongodbUpdateOperators.has(op)) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n    if (val != null && val.$__) {\n      val = val.toObject(internalToObjectOptions);\n      ret[op] = val;\n    }\n    if (val && typeof val === 'object' && !Buffer.isBuffer(val) && mongodbUpdateOperators.has(op)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. ' + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n  if (Object.keys(ret).length === 0 && options.upsert && Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    // Shallow clone to avoid passing defaults in re: gh-13962\n    return {\n      $setOnInsert: {\n        ...filter\n      }\n    };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' + ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj part of a query\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {Object} filter\n * @param {String} pref path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n  let aggregatedError = null;\n  const strictMode = strict != null ? strict : schema.options.strict;\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n    const discriminatorKey = prefix ? prefix + key : key;\n    if (schema.discriminatorMapping != null && discriminatorKey === schema.options.discriminatorKey && schema.discriminatorMapping.value !== obj[key] && !options.overwriteDiscriminatorKey) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (op !== '$setOnInsert' && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(null, val, context, {\n                strict: _strict\n              });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n          hasKeys = true;\n        }\n      } else if (op === '$currentDate' || op in castOps && schematype) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      } else {\n        const pathToCheck = prefix + key;\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) || utils.isObject(val) && Object.keys(val).length === 0;\n      }\n    } else {\n      const checkPath = key === '$each' || key === '$or' || key === '$and' || key === '$in' ? pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' && handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n      let isStrict = strict;\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n      const skip = isStrict && !schematype && !/real|nested/.test(pathDetails.pathType);\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else if (isStrict !== false || schematype != null) {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype && schematype.caster && !schematype.caster.$isMongooseArray && !schematype.caster[schemaMixedSymbol]) {\n            obj[key] = {\n              $each: obj[key]\n            };\n          }\n        }\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n        hasKeys = true;\n      }\n    }\n  }\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\n * These operators should be cast to numbers instead\n * of their path schema type.\n * @api private\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\n * These ops require no casting because the RHS doesn't do anything.\n * @api private\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\n * These operators require casting docs\n * to real Documents for Update operations.\n * @api private\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @param {String} path\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  // console.log('CastUpdateVal', path, op, val, schema);\n\n  const cond = schema.caster && op in castOps && (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQuery(null, val, context);\n    }\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return {\n        $type: val.$type\n      };\n    }\n    return Boolean(val);\n  }\n  if (mongodbUpdateOperators.has($conditional)) {\n    return schema.castForQuery($conditional, val, context);\n  }\n  if (overwriteOps[op]) {\n    const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/);\n    const applySetters = schema[schemaMixedSymbol] != null;\n    if (skipQueryCastForUpdate || applySetters) {\n      return schema.applySetters(val, context);\n    }\n    return schema.castForQuery(null, val, context);\n  }\n  return schema.castForQuery(null, val, context);\n}","map":{"version":3,"names":["CastError","require","MongooseError","StrictModeError","ValidationError","castNumber","cast","getConstructorName","getEmbeddedDiscriminatorPath","handleImmutable","moveImmutableProperties","schemaMixedSymbol","setDottedPath","utils","internalToObjectOptions","mongodbUpdateOperators","Set","module","exports","castUpdate","schema","obj","options","context","filter","undefined","Array","isArray","len","length","i","ops","Object","keys","op","castPipelineOperator","upsert","ret","val","hasDollarKey","has","$set","splice","indexOf","push","startsWith","$__","toObject","Buffer","isBuffer","walkUpdatePath","msg","Error","isEmptyObject","$setOnInsert","find","v","pref","strict","prefix","hasKeys","schematype","key","aggregatedError","strictMode","_getSchema","_res","discriminatorKey","discriminatorMapping","value","overwriteDiscriminatorKey","err","_appendError","caster","castOps","$each","castUpdateVal","error","$slice","$sort","$position","$isSingleNested","_strict","castForQuery","pathToCheck","_getPathType","pathType","isObject","checkPath","pathDetails","type","isStrict","skip","test","virtuals","$isMongooseArray","query","multipleCastError","addError","numberOps","$pop","$inc","noCastOps","$unset","$push","$addToSet","overwriteOps","$conditional","path","cond","schemaArrayDepth","cur","arrayDepth","_val","additionalNesting","tmp","applySetters","$type","Boolean","skipQueryCastForUpdate","$fullPath","match"],"sources":["E:/Out/my-outpass/node_modules/mongoose/lib/helpers/query/castUpdate.js"],"sourcesContent":["'use strict';\n\nconst CastError = require('../../error/cast');\nconst MongooseError = require('../../error/mongooseError');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst cast = require('../../cast');\nconst getConstructorName = require('../getConstructorName');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst handleImmutable = require('./handleImmutable');\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst setDottedPath = require('../path/setDottedPath');\nconst utils = require('../../utils');\nconst { internalToObjectOptions } = require('../../options');\n\nconst mongodbUpdateOperators = new Set([\n  '$currentDate',\n  '$inc',\n  '$min',\n  '$max',\n  '$mul',\n  '$rename',\n  '$set',\n  '$setOnInsert',\n  '$unset',\n  '$addToSet',\n  '$pop',\n  '$pull',\n  '$push',\n  '$pullAll',\n  '$bit'\n]);\n\n/**\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n * @api private\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    if (!mongodbUpdateOperators.has(op)) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n    if (val != null && val.$__) {\n      val = val.toObject(internalToObjectOptions);\n      ret[op] = val;\n    }\n    if (val &&\n        typeof val === 'object' &&\n        !Buffer.isBuffer(val) &&\n        mongodbUpdateOperators.has(op)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n\n  if (Object.keys(ret).length === 0 &&\n      options.upsert &&\n      Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    // Shallow clone to avoid passing defaults in re: gh-13962\n    return { $setOnInsert: { ...filter } };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' +\n        ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj part of a query\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {Object} filter\n * @param {String} pref path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, pref) {\n  const strict = options.strict;\n  const prefix = pref ? pref + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n\n  let aggregatedError = null;\n\n  const strictMode = strict != null ? strict : schema.options.strict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n\n    const discriminatorKey = (prefix ? prefix + key : key);\n    if (\n      schema.discriminatorMapping != null &&\n      discriminatorKey === schema.options.discriminatorKey &&\n      schema.discriminatorMapping.value !== obj[key] &&\n      !options.overwriteDiscriminatorKey\n    ) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(null, val, context, { strict: _strict });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = (prefix + key);\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      const checkPath = (key === '$each' || key === '$or' || key === '$and' || key === '$in') ?\n        pref : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, context)) {\n        continue;\n      }\n\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict &&\n        !schematype &&\n        !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        // gh-1845 temporary fix: ignore $rename. See gh-3027 for tracking\n        // improving this.\n        if (op === '$rename') {\n          hasKeys = true;\n          continue;\n        }\n\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else if (isStrict !== false || schematype != null) {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype &&\n              schematype.caster &&\n              !schematype.caster.$isMongooseArray &&\n              !schematype.caster[schemaMixedSymbol]) {\n            obj[key] = { $each: obj[key] };\n          }\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\n * These operators should be cast to numbers instead\n * of their path schema type.\n * @api private\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\n * These ops require no casting because the RHS doesn't do anything.\n * @api private\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\n * These operators require casting docs\n * to real Documents for Update operations.\n * @api private\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @param {String} path\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  // console.log('CastUpdateVal', path, op, val, schema);\n\n  const cond = schema.caster && op in castOps &&\n      (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQuery(\n        null,\n        val,\n        context\n      );\n    }\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return { $type: val.$type };\n    }\n    return Boolean(val);\n  }\n\n  if (mongodbUpdateOperators.has($conditional)) {\n    return schema.castForQuery(\n      $conditional,\n      val,\n      context\n    );\n  }\n\n  if (overwriteOps[op]) {\n    const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/);\n    const applySetters = schema[schemaMixedSymbol] != null;\n    if (skipQueryCastForUpdate || applySetters) {\n      return schema.applySetters(val, context);\n    }\n    return schema.castForQuery(\n      null,\n      val,\n      context\n    );\n  }\n\n  return schema.castForQuery(null, val, context);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}