{"ast":null,"code":"'use strict';\n\n/*!\n * ignore\n */\nconst Mixed = require('../../schema/mixed');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst mpath = require('mpath');\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\n\n/**\n * Given a model and its schema, find all possible schema types for `path`,\n * including searching through discriminators. If `doc` is specified, will\n * use the doc's values for discriminator keys when searching, otherwise\n * will search all discriminators.\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n * @api private\n */\n\nmodule.exports = function getSchemaTypes(model, schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n  const discriminatorKey = schema.discriminatorMapping && schema.discriminatorMapping.key;\n  if (discriminatorKey && model != null) {\n    if (doc != null && doc[discriminatorKey] != null) {\n      const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      schema = discriminator ? discriminator.schema : schema;\n    } else if (model.discriminators != null) {\n      return Object.keys(model.discriminators).reduce((arr, name) => {\n        const disc = model.discriminators[name];\n        return arr.concat(getSchemaTypes(disc, disc.schema, null, path));\n      }, []);\n    }\n  }\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n        let schemas = null;\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' + foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).reduce(function (cur, discriminator) {\n            const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n            if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n              cur.push(discriminators[discriminator]);\n            }\n            return cur;\n          }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(parts.slice(p + 1), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(parts.slice(p), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n              if (_ret != null) {\n                _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);\n                if (_ret.$parentSchemaDocArray) {\n                  ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(parts.slice(p), foundschema.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n        } else if (p !== parts.length && foundschema.$isMongooseArray && foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n          const ret = search(parts.slice(p), type.schema, null, nestedPath.concat(parts.slice(0, p)));\n          if (ret != null) {\n            return ret;\n          }\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {\n        return foundschema.$__schemaType;\n      }\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts.length) {\n        const model = doc.$__.populated[fullPath].options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(parts.slice(p), model.schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n          return ret;\n        }\n      }\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ? leanPopulateMap.get(_val[0]) : leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(parts.slice(p), schema, subdoc ? mpath.get(trypath, subdoc) : null, nestedPath.concat(parts.slice(0, p)));\n          if (ret != null) {\n            ret.$parentSchemaDocArray = ret.$parentSchemaDocArray || (schema.$isSingleNested ? null : schema);\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};","map":{"version":3,"names":["Mixed","require","get","getDiscriminatorByValue","leanPopulateMap","mpath","populateModelSymbol","module","exports","getSchemaTypes","model","schema","doc","path","pathschema","topLevelDoc","discriminatorKey","discriminatorMapping","key","discriminator","discriminators","Object","keys","reduce","arr","name","disc","concat","search","parts","subdoc","nestedPath","p","length","foundschema","trypath","slice","join","caster","schemas","discriminatorKeyPath","options","cur","tiedValue","value","indexOf","push","ret","$parentSchemaDocArray","$isSingleNested","_ret","$isMongooseArray","casterConstructor","type","$isMongooseDocumentArray","discriminatorPaths","discriminatorName","_schema","$isSchemaMap","$__schemaType","fullPath","$__","$populated","populated","_val","Array","isArray","split","i"],"sources":["E:/Out/my-outpass/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nconst Mixed = require('../../schema/mixed');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst mpath = require('mpath');\n\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\n\n/**\n * Given a model and its schema, find all possible schema types for `path`,\n * including searching through discriminators. If `doc` is specified, will\n * use the doc's values for discriminator keys when searching, otherwise\n * will search all discriminators.\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n * @api private\n */\n\nmodule.exports = function getSchemaTypes(model, schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n\n  const discriminatorKey = schema.discriminatorMapping &&\n    schema.discriminatorMapping.key;\n  if (discriminatorKey && model != null) {\n    if (doc != null && doc[discriminatorKey] != null) {\n      const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      schema = discriminator ? discriminator.schema : schema;\n    } else if (model.discriminators != null) {\n      return Object.keys(model.discriminators).reduce((arr, name) => {\n        const disc = model.discriminators[name];\n        return arr.concat(getSchemaTypes(disc, disc.schema, null, path));\n      }, []);\n    }\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n\n        let schemas = null;\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' +\n            foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).\n            reduce(function(cur, discriminator) {\n              const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n                cur.push(discriminators[discriminator]);\n              }\n              return cur;\n            }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(\n              parts.slice(p + 1),\n              schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(\n                parts.slice(p),\n                schema,\n                subdoc ? mpath.get(trypath, subdoc) : null,\n                nestedPath.concat(parts.slice(0, p))\n              );\n              if (_ret != null) {\n                _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n                if (_ret.$parentSchemaDocArray) {\n                  ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(\n              parts.slice(p),\n              foundschema.schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n        } else if (p !== parts.length &&\n            foundschema.$isMongooseArray &&\n            foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n\n          const ret = search(\n            parts.slice(p),\n            type.schema,\n            null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n          if (ret != null) {\n            return ret;\n          }\n\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {\n        return foundschema.$__schemaType;\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath) && p < parts.length) {\n        const model = doc.$__.populated[fullPath].options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(\n            parts.slice(p),\n            model.schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ?\n          leanPopulateMap.get(_val[0]) :\n          leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret != null) {\n            ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n              (schema.$isSingleNested ? null : schema);\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}