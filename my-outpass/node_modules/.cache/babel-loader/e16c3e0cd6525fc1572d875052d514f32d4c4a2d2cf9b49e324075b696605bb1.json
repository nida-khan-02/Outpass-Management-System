{"ast":null,"code":"'use strict';\n\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst updatedPathsByArrayFilter = require('../update/updatedPathsByArrayFilter');\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n * @param {Schema} schema\n * @param {Object} [update]\n * @param {Object} [filter]\n * @param {String} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ? options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) && schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath = discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n      if (schematype.$isMongooseDocumentArrayElement && get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n      if (discriminatorKey == null) {\n        continue;\n      }\n      const discriminator = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey);\n      const discriminatorSchema = discriminator && discriminator.schema;\n      if (discriminatorSchema == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n  return {\n    type: type,\n    schematype: schematype\n  };\n};","map":{"version":3,"names":["cleanPositionalOperators","require","get","getDiscriminatorByValue","updatedPathsByArrayFilter","module","exports","getEmbeddedDiscriminatorPath","schema","update","filter","path","options","parts","split","schematype","type","arrayFilters","Array","isArray","updatedPathsByFilter","i","length","subpath","slice","join","pathType","$isSingleNested","$isMongooseDocumentArrayElement","discriminators","key","discriminatorValuePath","discriminatorFilterPath","replace","discriminatorKey","wrapperPath","$elemMatch","filterKey","Object","keys","schemaKey","arrayFilterKey","find","hasOwnProperty","discriminator","caster","discriminatorSchema","rest","_getPathType"],"sources":["E:/Out/my-outpass/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js"],"sourcesContent":["'use strict';\n\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst updatedPathsByArrayFilter = require('../update/updatedPathsByArrayFilter');\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n * @param {Schema} schema\n * @param {Object} [update]\n * @param {Object} [filter]\n * @param {String} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ?\n    options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = cleanPositionalOperators(parts.slice(0, i + 1).join('.'));\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&\n        schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath =\n        discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n      if (schematype.$isMongooseDocumentArrayElement &&\n          get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n\n      if (discriminatorKey == null) {\n        continue;\n      }\n\n      const discriminator = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey);\n      const discriminatorSchema = discriminator && discriminator.schema;\n      if (discriminatorSchema == null) {\n        continue;\n      }\n\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n\n  return { type: type, schematype: schematype };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}